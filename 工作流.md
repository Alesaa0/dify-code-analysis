工作流将一系列节点串联自动化执行得到结果，每个节点用到前驱节点的输出，同时又是后继节点的输入。这种可以将复杂的任务分解成 较小的步骤（节点）去执行，降低了系统复杂度，减少了对提示词的依赖。

### 目录结构和文件功能概述

`api/core/workflow` 模块包含以下文件和子目录：

1. **根目录**

   - `__init__.py`: 初始化模块

   - `errors.py`: 错误定义

   - `workflow_engine_manager.py`: 工作流引擎管理。包括以下几个主要逻辑：

     1. **获取默认配置**：获取所有节点的默认配置（比如节点类型）

     2. **运行工作流**：包含工作流的初始化、变量池的创建、工作流执行等。

     3. **单步运行节点**：实现单步运行节点的逻辑，用于调试或特定需求。

        1. :param workflow: Workflow instance 

           :param node_id: node id 

           :param user_id: user id 

           :param user_inputs: user inputs 

           :return: tuple[node_instance, node_run_result]

     4. **迭代运行节点**：实现迭代节点的单步运行逻辑，用于处理迭代或**循环**结构的工作流节点。

     5. **处理工作流运行成功和失败**：这里主要是使用定义的一系列workflow callbacks。

2. **callbacks 子目录**

   - `__init__.py`: 初始化模块

   - `base_workflow_callback.py`: 基础工作流回调类。定义了基础工作流回调类 `BaseWorkflowCallback`，包含工作流运行开始、成功、失败等回调方法。

     - #### 功能逻辑

       `base_workflow_callback.py` 文件定义了一个基础的工作流回调类 `BaseWorkflowCallback`。该类提供了工作流在不同运行状态下（开始、成功、失败、节点执行开始、节点执行成功、节点执行失败）的回调方法。这些方法可以在具体实现中被继承和覆盖，以实现特定的业务逻辑。

       #### 实现功能

       `BaseWorkflowCallback` 类的主要功能是提供一组可在工作流运行过程中触发的回调方法。通过继承和实现这些回调方法，开发者可以自定义在工作流的不同阶段执行的操作。

       以下是 `BaseWorkflowCallback` 类中定义的回调方法：

       1. `on_workflow_run_started()`: 工作流运行开始时触发。
       2. `on_workflow_run_succeeded()`: 工作流运行成功时触发。
       3. `on_workflow_run_failed(error)`: 工作流运行失败时触发，并传递错误信息。
       4. `on_workflow_node_run_started(node)`: 工作流节点开始运行时触发，并传递节点信息。
       5. `on_workflow_node_run_succeeded(node, result)`: 工作流节点运行成功时触发，并传递节点信息和运行结果。
       6. `on_workflow_node_run_failed(node, error)`: 工作流节点运行失败时触发，并传递节点信息和错误信息。

       #### 输入输出情况

       - **输入**：每个回调方法根据其用途，接收不同的参数。例如，工作流运行失败时 `on_workflow_run_failed` 方法接收一个 `error` 参数，节点运行成功时 `on_workflow_node_run_succeeded` 方法接收 `node` 和 `result` 参数。
       - **输出**：这些回调方法通常不返回值，具体实现中可以通过覆盖这些方法来定义在这些事件发生时需要执行的操作（如日志记录、通知等）。

3. **entities 子目录**

   - `__init__.py`: 初始化模块
   - `base_node_data_entities.py`: 基础节点数据实体类
   - `node_entities.py`: 节点实体类
   - `variable_entities.py`: 变量实体类
   - `variable_pool.py`: 变量池管理
   - `workflow_entities.py`: 工作流实体类

4. **nodes 子目录**

   - `__init__.py`: 初始化模块

   - 各种节点（如 `answer`, `code`, `end`, `http_request`, `if_else`, `iteration`, `knowledge_retrieval`, `llm`, `loop`, `parameter_extractor`, `question_classifier`, `start`, `template_transform`, `tool`, `variable_aggregator`）及其相关文件

     - **answer 子目录**

       - `answer_node.py`: 实现直接回复节点的逻辑，处理回答生成的具体操作。

         - `answer_node.py` 实现了回答节点 `AnswerNode` 的逻辑，负责处理回答生成的具体操作。其主要逻辑包括：

           1. **节点运行**：执行节点，生成回答。
           2. **生成路径提取**：从节点数据中提取生成路径。因为对于answer节点来说，用户可能会用文本或变量来拼接答案，然而我们输出的answer是字符串类型的，所以就需要根据生成的路径（文本路径、变量路径）来进行不同的处理。
           3. **变量选择器映射**：将变量选择器映射到具体的变量值。

           ##### 主要方法

           1. **`_run` 方法**：运行节点逻辑，根据生成路径生成回答。
           2. **`extract_generate_route_selectors` 方法**：从配置中提取生成路径选择器。
           3. **`extract_generate_route_from_node_data` 方法**：从节点数据中提取生成路径。
           4. **`_is_variable` 方法**：判断一个部分是否是变量。
           5. **`_extract_variable_selector_to_variable_mapping` 方法**：提取变量选择器与变量的映射关系。

           ##### 输入输出情况

           - **输入**：变量池 `VariablePool`，节点配置 `config`，节点数据 `node_data`。
           - **输出**：节点运行结果 `NodeRunResult`，包括生成的回答 `answer`。

       - `entities.py`: 定义了回答节点所需的实体类，可能包括回答的内容、格式等。

         - `entities.py` 定义了回答节点所需的实体类，描述回答的内容和生成路径的相关数据结构。

           ##### 主要类

           1. **`AnswerNodeData` 类**：表示回答节点的数据，包含回答模板 `answer`。
           2. **`GenerateRouteChunk` 类**：表示生成路径的基本单元，包含路径类型 `type`。
           3. **`VarGenerateRouteChunk` 类**：表示变量生成路径单元，包含变量选择器 `value_selector`。
           4. **`TextGenerateRouteChunk` 类**：表示文本生成路径单元，包含文本内容 `text`。

           ##### 输入输出情况

           - **输入**：节点数据 `AnswerNodeData`，生成路径数据 `GenerateRouteChunk`。
           - **输出**：实例化的节点数据和生成路径数据。

       **code 子目录**

       - `code_node.py`: 实现代码执行节点的逻辑，处理代码执行的具体操作。

         - ### 主要逻辑

           1. **获取默认配置 (`get_default_config` 方法)**:
              - 根据传入的过滤条件（如编程语言），返回对应编程语言的默认配置。（支持Python / NodeJS）
           2. **执行代码 (`_run` 方法)**:
              - 从节点数据中提取代码语言和代码内容。
              - 从 `VariablePool` 中获取代码所需的变量。
              - 使用 `CodeExecutor` 执行代码，并传入编程语言、代码、变量和依赖项。
              - 捕获执行过程中的异常（如 `CodeExecutionException` 和 `ValueError`），并返回失败状态。
              - 转换执行结果（通过 `_transform_result` 方法）并返回成功状态。
           3. **转换结果 (`_transform_result` 方法)**:
              - 递归地根据输出模式（`output_schema`）验证和转换结果。
              - 支持**对象、数字、字符串、数组**等类型的结果。
              - 处理深度嵌套的对象和数组，确保输出结果符合预期的模式。
           4. **提取变量选择器到变量的映射 (`_extract_variable_selector_to_variable_mapping` 方法)**:
              - 从节点数据中提取变量选择器及其对应的变量映射。

       - `entities.py`: 定义了代码节点所需的实体类，可能包括代码的内容、执行结果等。

       **end 子目录**

       - `end_node.py`: 实现结束节点的逻辑，处理工作流结束时的操作。
         - 从 `variable_pool` 中提取输出变量的值，并返回这些值作为节点的输出。
       - `entities.py`: 定义了结束节点所需的实体类，可能包括结束状态、结果等。

       **http_request 子目录**

       - `http_executor.py`: 实现HTTP请求的执行逻辑，处理HTTP请求的发送和接收。
       - `http_request_node.py`: 实现HTTP请求节点的逻辑，处理HTTP请求的具体操作。
         - HTTP 请求的返回值包括**响应体、状态码、响应头和文件**。值得注意的是，如果响应中包含了文件（目前仅支持**图片**类型），这个节点能够自动将文件保存下来，供流程后续步骤使用。这样的设计不仅提高了处理效率，也使得处理带有文件的响应变得简单直接。
       - `entities.py`: 定义了HTTP请求节点所需的实体类，可能包括请求URL、方法、参数等。

       **if_else 子目录**

       - `if_else_node.py`: 实现条件分支节点的逻辑，处理条件判断的具体操作。

         - **`_run`** 方法是类的核心，负责评估条件并决定节点的执行路径。它首先从 `node_data` 中获取条件，然后根据条件的比较操作符调用相应的断言方法进行比较。最终，根据逻辑操作符（“and” 或 “or”）计算条件的总体结果。此处返回结果对象，包含属性 outputs={

           ​                "result": True/False

           ​            }

           **断言方法** 提供了多种条件比较方式，支持字符串和数值的比较。这些方法确保条件判断的灵活性和准确性。

       - `entities.py`: 定义了if-else节点所需的实体类，可能包括条件表达式、判断结果等。

       **iteration 子目录**

       - `iteration_node.py`: 实现迭代节点的逻辑，处理迭代操作的具体过程。
       - `entities.py`: 定义了迭代节点所需的实体类，可能包括迭代次数、迭代条件等。

       **knowledge_retrieval 子目录**

       - `knowledge_retrieval_node.py`: 实现知识检索节点的逻辑，处理知识检索的具体操作。
       - `entities.py`: 定义了知识检索节点所需的实体类，可能包括检索的内容、结果等。

       **llm 子目录**

       - `llm_node.py`: 实现LLM节点的逻辑，处理大语言模型的具体操作。
       - `entities.py`: 定义了LLM节点所需的实体类，可能包括模型参数、结果等。

       **parameter_extractor 子目录**

       - `parameter_extractor_node.py`: 实现参数提取节点的逻辑，处理参数提取的具体操作。输出我们想要提取的模版参数。
       - `prompts.py`: 提供提取参数的**提示模板**。我们的参数提取功能主要根据调好prompt来实现。
       - `entities.py`: 定义了参数提取节点所需的实体类，可能包括提取的参数名、参数值等。

       **question_classifier 子目录**

       - `question_classifier_node.py`: 实现问题分类节点的逻辑，处理问题分类的具体操作。输出llm认为所属问题的问题分类。
       - `template_prompts.py`: 提供问题分类的模板提示。我们的问题分类功能主要根据调好prompt来实现。
       - `entities.py`: 定义了问题分类节点所需的实体类，可能包括分类标准、分类结果等。

       **start 子目录**

       - `start_node.py`: 实现开始节点的逻辑，处理工作流开始时的操作。收集并整合所有的变量（包括用户变量和系统变量），并将它们作为输入和输出返回。
       - `entities.py`: 定义了开始节点所需的实体类，可能包括启动参数、初始状态等。

       **template_transform 子目录**

       - `template_transform_node.py`: 实现模板转换节点的逻辑，处理模板转换的具体操作。该节点使用 Jinja2 模板引擎来处理模板，这是一个强大的工具，用于生成基于变量的动态内容。
       - `entities.py`: 定义了模板转换节点所需的实体类，可能包括模板内容、转换规则等。

       **tool 子目录**

       - `tool_node.py`: 实现工具节点的逻辑，处理工具操作的具体过程。这里的outputs可能会有如下类型{

         ​                'text': plain_text,

         ​                'files': files,

         ​                'json': json

         ​            },

         主要取决于tool里输出的类型是什么。

       - `entities.py`: 定义了工具节点所需的实体类，可能包括工具类型、参数等。

       **variable_aggregator 子目录**

       - `variable_aggregator_node.py`: 实现变量聚合节点的逻辑，处理变量聚合的具体操作。它负责整合不同分支的输出结果，确保无论哪个分支被执行，其结果都能通过一个统一的变量来引用和访问。这在多分支的情况下非常有用，可将不同分支下相同作用的变量映射为一个输出变量，避免下游节点重复定义。

         ​	变量聚合器支持聚合多种数据类型，包括字符串（`String`）、数字（`Number`）、对象（`Object`）以及数组（`Array`）。

         ​	**变量聚合器只能聚合同一种数据类型的变量**。若第一个添加至变量聚合节点内的变量数据格式为 `String`，后续连线时会自动过滤可添加变量为 `String` 类型。

       - `entities.py`: 定义了变量聚合节点所需的实体类，可能包括聚合方式、结果等。

5. **utils 子目录**

   - `__init__.py`: 初始化模块

   - `variable_template_parser.py`: 变量模板解析器，用于解析和处理工作流中的变量模板。它的主要功能是从模板字符串中提取变量，并根据给定的变量值生成最终的字符串输出。

     - #### 主要逻辑

       1. **定义模板变量的格式**：模板变量通常以某种特定的标记符包围，例如 `${variable_name}`。在代码中可以通过正则表达式来定义和识别这些变量。
       2. **解析模板字符串**：解析模板字符串的逻辑主要是识别出模板中的变量部分。通过正则表达式查找所有匹配的变量。
       3. **替换模板中的变量**：根据给定的变量值，将模板中的变量替换为实际的值。这个功能可以通过简单的字符串替换来实现。
       4. **处理嵌套变量**：在实际应用中，变量的值可能本身也是一个模板字符串，这种情况下需要递归处理嵌套的变量。
       5. **提供解析结果**：解析并替换模板字符串中的变量。